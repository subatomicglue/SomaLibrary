<script>
  /////////////////////////////////////////
  // Mark search terms and scroll logic
  function markupSearchTerms(term) {
    if (!term) return;

    const searchRegex = new RegExp(term, 'gi');
    const container = document.getElementById('the-scroll-page');
    if (!container) return;

    clearMarks();

    // Get all text nodes
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
    const textNodes = [];
    let node;
    while ((node = walker.nextNode())) {
      if (node.parentNode && !['SCRIPT', 'STYLE'].includes(node.parentNode.tagName)) {
        textNodes.push(node);
      }
    }

    // Replace matches with <mark>
    textNodes.forEach(textNode => {
      const replaced = textNode.nodeValue.replace(searchRegex, match => `<mark>${match}</mark>`);
      if (replaced !== textNode.nodeValue) {
        const span = document.createElement('span');
        span.innerHTML = replaced;
        textNode.parentNode.replaceChild(span, textNode);
      }
    });
  }

  function saveModePreference() {
    localStorage.setItem( "search-mode", document.getElementById('search-mode').innerHTML )
  }
  function loadModePreference() {
    document.getElementById('search-mode').innerHTML = localStorage.getItem( "search-mode" ) ? localStorage.getItem( "search-mode" ) : search_mode_init_text
  }

  function getSearchTerm() {
    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);
    return params.get('searchterm') || '';
  }

  // Navigation logic
  let currentIndex = 0;

  function scrollToMark(index) {
    const marks = document.querySelectorAll('mark');

    if (marks.length === 0) return;

    // disable "goto next/prev mark" wrap-around.
    //if (index < 0 || index >= marks.length) return;

    currentIndex = ((index % marks.length) + marks.length) % marks.length;
    marks[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });

    // set the style on the marks
    let counter = 0;
    marks.forEach(mark => {
      if (counter++ === currentIndex)
        mark.className = 'selected';
      else
        mark.removeAttribute('class');
    });

    updateCounterDisplay();
  }

  function isSearching() {
    const controlDiv = document.getElementById('searchcontrol');
    return controlDiv.style.display != 'none'
  }
  function isSearchModeGlobal() {
    const searchMode = document.getElementById('search-mode')
    return searchMode.innerHTML == search_mode_global_text
  }
  function isSearchModeLocal() {
    const searchMode = document.getElementById('search-mode')
    return searchMode.innerHTML == search_mode_local_text
  }

  function updateCounterDisplay() {
    const marks = document.querySelectorAll('mark');
    const counter = document.getElementById('mark-counter');
    if (counter) {
      if (marks.length === 0) {
        counter.textContent = '0/0';
      } else {
        counter.textContent = `${currentIndex + 1}/${marks.length}`;
      }
    }
  }

  function nextMark() {
    const marks = document.querySelectorAll('mark');
    //if (currentIndex < (marks.length - 1)) {
      scrollToMark(currentIndex + 1);
    //}
  }

  function prevMark() {
    //if (currentIndex > 0) {
      scrollToMark(currentIndex - 1);
    //}
  }

  function clearMarks() {
    const container = document.getElementById('the-scroll-page');
    if (!container) return;
    const oldMarks = container.querySelectorAll('mark');

    oldMarks.forEach(mark => {
      const prevNode = mark.previousSibling;
      const nextNode = mark.nextSibling;
      
      const textContent = mark.textContent;

      let combinedText = textContent;
      
      if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
        combinedText = prevNode.textContent + combinedText;
        prevNode.remove();
      }

      if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
        combinedText += nextNode.textContent;
        nextNode.remove();
      }

      const textNode = document.createTextNode(combinedText);
      mark.replaceWith(textNode);
    });
  }

  // Helper to clear the searchterm from URL without reloading
  function clearSearchTermFromURL() {
    updateSearchTermInURL('')
  }

  function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        func.apply(this, args); // Call the function with the provided arguments
      }, delay);
    };
  }

  function updateSearchTermInURL(term) {
    const url = new URL(window.location.href);
    if (term === '') {
      url.searchParams.delete('searchterm');
      storeScrollPosition();
      window.history.pushState({}, document.title, url.toString());
    } else {
      url.searchParams.set('searchterm', term);
      window.history.replaceState({}, document.title, url.toString());
    }
  }
  const debouncedUpdateSearchTermInURL = debounce(updateSearchTermInURL, 100);

  function storeScrollPosition() {
    const scrollPosition = window.scrollY || window.pageYOffset;
    sessionStorage.setItem('scrollPosition', scrollPosition);
  }

  function restoreScrollPosition() {
    const storedScrollPosition = sessionStorage.getItem('scrollPosition');
    if (storedScrollPosition) {
      window.scrollTo(0, parseInt(storedScrollPosition, 10));
      sessionStorage.removeItem('scrollPosition');  // clean up storage
    }
  }

  function focusSearchEditBox() {
    const searchBox = document.getElementById('search-box');
    searchBox.focus();  // focus the input box
    searchBox.select(); // selects all the text
  }

  const search_mode_init_text = "!!! mode !!!";
  const search_mode_global_text = "ðŸŒŽ&nbsp;All&nbsp;Pages";
  const search_mode_local_text = "â–¼&nbsp;Page";
  // is meant to be called once on init() to initialize.   keep that in mind.
  function toggleMode(forcemode=undefined) {
    const searchMode = document.getElementById('search-mode')
    if (forcemode) {
      searchMode.innerHTML = forcemode
    } else {
      if (searchMode.innerHTML == search_mode_init_text) {
        loadModePreference()
        searchMode.innerHTML = searchMode.innerHTML == search_mode_init_text ? search_mode_local_text : searchMode.innerHTML
      } else {
        searchMode.innerHTML = searchMode.innerHTML != search_mode_local_text ? search_mode_local_text : search_mode_global_text;
      }
    }
    saveModePreference();
    document.getElementById('mark-counter').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none' 
    document.getElementById('search-local-prev').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none' 
    document.getElementById('search-local-next').style.display = searchMode.innerHTML == search_mode_local_text ? 'inline-block' : 'none'
    document.getElementById('search-global-enter').style.display = searchMode.innerHTML == search_mode_global_text ? 'inline-block' : 'none'
    focusSearchEditBox()
  }

  // Add search control UI
  // Helper to clear marks
  function addSearchControl(term) {
    const controlDiv = document.getElementById('searchcontrol');
    if (!controlDiv) return;

    controlDiv.style.display = 'block';
    controlDiv.innerHTML = `
      <div class="search-inner" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.3rem; width: 100%;">
        <button id="search-mode" style="width:auto; padding-left: 0.25rem; padding-right: 0.25rem;">!!! mode !!!</button>
        <input id="search-box" type="text" value="${term}" autofocus>
        <span id="mark-counter">0/0</span>
        <button id="search-local-prev"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_up_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
        <button id="search-local-next"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_down_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
        <button id="search-global-enter" style="width:auto; padding-left: 0.25rem; padding-right: 0.25rem;">Search</button>
        <button id="search-clear" title="Clear search" style="font-weight: bold; font-size: 1.2rem; cursor: pointer;"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/close_small_24dp_FFFFFF_FILL0_wght400_GRAD0_opsz24.svg"></button>
      </div>
    `;

    document.getElementById('search-local-prev').addEventListener('click', prevMark);
    document.getElementById('search-local-next').addEventListener('click', nextMark);
    document.getElementById('search-global-enter').addEventListener('click', () => {
      const searchterm = document.getElementById('search-box').value.trim();
      const newurl = `<%=SEARCH_URL%>${searchterm != '' ? `?searchterm=${searchterm}` : ''}`
      console.log( newurl )
      window.location.href = newurl;
    });

    focusSearchEditBox();

    const searchBox = document.getElementById('search-box');
    searchBox.addEventListener('input', () => {
      const newTerm = searchBox.value.trim();
      if (newTerm === '') {
        clearMarks();
        updateCounterDisplay();
      } else {
        markupSearchTerms(newTerm);
        currentIndex = 0;
        scrollToMark(0);
      }

      debouncedUpdateSearchTermInURL( newTerm )
    });

    // Clear (X) button logic
    document.getElementById('search-clear').addEventListener('click', () => {
      onCancel();
    });

    // mode toggle
    const searchMode = document.getElementById('search-mode')
    toggleMode(); // init mode
    searchMode.addEventListener('click', () => toggleMode() );
  }

  function onCancel() {
    const searchBox = document.getElementById('search-box');
    const controlDiv = document.getElementById('searchcontrol');

    // Clear input box
    searchBox.value = '';
    
      // Clear marks
    clearMarks();
    // Update counter display
    updateCounterDisplay();
    // Remove searchterm from URL (no reload)
    clearSearchTermFromURL();
    // Hide the search control bar if desired:
    controlDiv.style.display = 'none';
  }




  document.addEventListener('DOMContentLoaded', () => {
    const term = getSearchTerm();
    if (term) {
      // pop up search box.
      search();
      toggleMode(search_mode_local_text);
    } else {
      restoreScrollPosition(); // if set from previous page navigation, restore it
    }
  });

  document.addEventListener('keydown', (e) => {
    // page handler
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
      e.preventDefault();

      // pop up search box.
      search();
    }

    // handler active only when searching
    if (isSearching() && e.key === 'Enter') {
      if (isSearchModeLocal())
        nextMark();
      else
        document.getElementById('search-global-enter').click();
    }

    // handler active only when searching
    if (isSearching() && e.key === 'Escape') {
      onCancel();
    }
  });

  // open the search dialog, or close it if already open.
  function search() {
    if (isSearching()) {
      onCancel();
    } else {
      const term = getSearchTerm();
      if (term && term != '') markupSearchTerms(term);
      addSearchControl(term);
      if (term && term != '') 
        scrollToMark(0);
    }
  }
  /////////////////////////////////////////
</script>
