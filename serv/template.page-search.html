<script>
  /////////////////////////////////////////
  // Mark search terms and scroll logic
  function markupSearchTerms(term) {
    if (!term) return;

    const searchRegex = new RegExp(term, 'gi');
    const container = document.getElementById('the-scroll-page');
    if (!container) return;

    clearMarks();

    // Get all text nodes
    const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null, false);
    const textNodes = [];
    let node;
    while ((node = walker.nextNode())) {
      if (node.parentNode && !['SCRIPT', 'STYLE'].includes(node.parentNode.tagName)) {
        textNodes.push(node);
      }
    }

    // Replace matches with <mark>
    textNodes.forEach(textNode => {
      const replaced = textNode.nodeValue.replace(searchRegex, match => `<mark>${match}</mark>`);
      if (replaced !== textNode.nodeValue) {
        const span = document.createElement('span');
        span.innerHTML = replaced;
        textNode.parentNode.replaceChild(span, textNode);
      }
    });
  }

  function getSearchTerm() {
    const url = new URL(window.location.href);
    const params = new URLSearchParams(url.search);
    return params.get('searchterm') || '';
  }

  // Navigation logic
  let currentIndex = 0;

  function scrollToMark(index) {
    const marks = document.querySelectorAll('mark');

    if (marks.length === 0) return;

    // disable "goto next/prev mark" wrap-around.
    //if (index < 0 || index >= marks.length) return;

    currentIndex = ((index % marks.length) + marks.length) % marks.length;
    marks[currentIndex].scrollIntoView({ behavior: 'smooth', block: 'start' });
    updateCounterDisplay();
  }

  function updateCounterDisplay() {
    const marks = document.querySelectorAll('mark');
    const counter = document.getElementById('mark-counter');
    if (counter) {
      if (marks.length === 0) {
        counter.textContent = '0/0';
      } else {
        counter.textContent = `${currentIndex + 1}/${marks.length}`;
      }
    }
  }

  function nextMark() {
    const marks = document.querySelectorAll('mark');
    //if (currentIndex < (marks.length - 1)) {
      scrollToMark(currentIndex + 1);
    //}
  }

  function prevMark() {
    //if (currentIndex > 0) {
      scrollToMark(currentIndex - 1);
    //}
  }

  function clearMarks() {
    const container = document.getElementById('the-scroll-page');
    if (!container) return;
    const oldMarks = container.querySelectorAll('mark');

    oldMarks.forEach(mark => {
      const prevNode = mark.previousSibling;
      const nextNode = mark.nextSibling;
      
      const textContent = mark.textContent;

      let combinedText = textContent;
      
      if (prevNode && prevNode.nodeType === Node.TEXT_NODE) {
        combinedText = prevNode.textContent + combinedText;
        prevNode.remove();
      }

      if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
        combinedText += nextNode.textContent;
        nextNode.remove();
      }

      const textNode = document.createTextNode(combinedText);
      mark.replaceWith(textNode);
    });
  }

  // Helper to clear the searchterm from URL without reloading
  function clearSearchTermFromURL() {
    updateSearchTermInURL('')
  }

  function debounce(func, delay) {
    let timeoutId;
    return function(...args) {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      timeoutId = setTimeout(() => {
        func.apply(this, args); // Call the function with the provided arguments
      }, delay);
    };
  }

  function updateSearchTermInURL(term) {
    const url = new URL(window.location.href);
    if (term === '') {
      url.searchParams.delete('searchterm');
      storeScrollPosition();
      window.history.pushState({}, document.title, url.toString());
    } else {
      url.searchParams.set('searchterm', term);
      window.history.replaceState({}, document.title, url.toString());
    }
  }
  const debouncedUpdateSearchTermInURL = debounce(updateSearchTermInURL, 100);

  function storeScrollPosition() {
    const scrollPosition = window.scrollY || window.pageYOffset;
    sessionStorage.setItem('scrollPosition', scrollPosition);
  }

  function restoreScrollPosition() {
    const storedScrollPosition = sessionStorage.getItem('scrollPosition');
    if (storedScrollPosition) {
      window.scrollTo(0, parseInt(storedScrollPosition, 10));
      sessionStorage.removeItem('scrollPosition');  // clean up storage
    }
  }

  // Add search control UI
  // Helper to clear marks
  function addSearchControl(term) {
    const controlDiv = document.getElementById('searchcontrol');
    if (!controlDiv) return;

    controlDiv.style.display = 'block';
    controlDiv.innerHTML = `
      <div class="search-inner" style="display: flex; justify-content: flex-end; align-items: center; gap: 0.3rem; width: 100%;">
        <input id="search-box" type="text" value="${term}" autofocus />
        <span id="mark-counter">0/0</span>
        <button id="search-prev"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_up_24dp_222222_FILL0_wght400_GRAD0_opsz24.svg"/></button>
        <button id="search-next"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/keyboard_arrow_down_24dp_222222_FILL0_wght400_GRAD0_opsz24.svg"/></button>
        <button id="search-clear" title="Clear search" style="font-weight: bold; font-size: 1.2rem; cursor: pointer;"><img class="buttonsvg" src="/<%=ASSETS_MAGIC%>/close_small_24dp_222222_FILL0_wght400_GRAD0_opsz24.svg"/></button>
      </div>
    `;

    document.getElementById('search-prev').addEventListener('click', prevMark);
    document.getElementById('search-next').addEventListener('click', nextMark);

    const searchBox = document.getElementById('search-box');
    searchBox.focus();  // focus the input box
    searchBox.select(); // selects all the text

    searchBox.addEventListener('input', () => {
      const newTerm = searchBox.value.trim();
      if (newTerm === '') {
        clearMarks();
        updateCounterDisplay();
      } else {
        markupSearchTerms(newTerm);
        currentIndex = 0;
        scrollToMark(0);
      }

      debouncedUpdateSearchTermInURL( newTerm )
    });

    // Clear (X) button logic
    document.getElementById('search-clear').addEventListener('click', () => {
      onCancel();
    });
  }

  function onCancel() {
    const searchBox = document.getElementById('search-box');
    const controlDiv = document.getElementById('searchcontrol');

    // Clear input box
    searchBox.value = '';
    
      // Clear marks
    clearMarks();
    // Update counter display
    updateCounterDisplay();
    // Remove searchterm from URL (no reload)
    clearSearchTermFromURL();
    // Hide the search control bar if desired:
    controlDiv.style.display = 'none';
  }


  document.addEventListener('DOMContentLoaded', () => {
    const term = getSearchTerm();
    if (term) {
      markupSearchTerms(term);
      addSearchControl(term);
      scrollToMark(0);
    } else {
      restoreScrollPosition(); // if set from previous page navigation, restore it
    }
  });

  document.addEventListener('keydown', function (e) {
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'f') {
      e.preventDefault();

      // Optional: open your search modal if you have one
      const term = getSearchTerm();
      if (term && term != '') markupSearchTerms(term);
      addSearchControl(term);
      if (term && term != '') 
        scrollToMark(0);
    }

    if (e.key === 'Enter') {
      console.log( "next")
      nextMark();
    }

    if (e.key === 'Escape') {
      onCancel();
    }
  });
  /////////////////////////////////////////
</script>
